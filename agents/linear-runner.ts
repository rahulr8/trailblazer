import { spawn } from "child_process";
import { createWriteStream, existsSync, readFileSync, writeFileSync } from "fs";
import { mkdir } from "fs/promises";
import path from "path";
import {
  getInProgressIssuesWithAgentLabel,
  markAsProcessing,
  markAsComplete,
  markAsFailed,
  getAgentType,
  LinearIssue
} from "./linear-client.js";

const POLL_INTERVAL_MS = 30000;
const LOGS_DIR = path.join(import.meta.dirname, "logs");
const PROCESSED_FILE = path.join(import.meta.dirname, "processed-issues.json");

interface ProcessedIssues {
  [issueId: string]: {
    identifier: string;
    processedAt: string;
    status: "success" | "failed";
    prUrl?: string;
    error?: string;
  };
}

function loadProcessedIssues(): ProcessedIssues {
  if (existsSync(PROCESSED_FILE)) {
    const content = readFileSync(PROCESSED_FILE, "utf-8");
    return JSON.parse(content) as ProcessedIssues;
  }
  return {};
}

function saveProcessedIssue(
  issueId: string,
  identifier: string,
  status: "success" | "failed",
  prUrl?: string,
  error?: string
): void {
  const processed = loadProcessedIssues();
  processed[issueId] = {
    identifier,
    processedAt: new Date().toISOString(),
    status,
    prUrl,
    error
  };
  writeFileSync(PROCESSED_FILE, JSON.stringify(processed, null, 2));
}

function isAlreadyProcessed(issueId: string): boolean {
  const processed = loadProcessedIssues();
  return issueId in processed;
}

function getLogFilePath(identifier: string): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
  return path.join(LOGS_DIR, `${identifier}-${timestamp}.log`);
}

async function createBranch(branchName: string): Promise<boolean> {
  return new Promise((resolve) => {
    const git = spawn("git", ["checkout", "-b", branchName], {
      cwd: path.join(import.meta.dirname, "..")
    });

    git.on("close", (code) => {
      if (code === 0) {
        console.log(`  Created branch: ${branchName}`);
        resolve(true);
      } else {
        const checkoutExisting = spawn("git", ["checkout", branchName], {
          cwd: path.join(import.meta.dirname, "..")
        });
        checkoutExisting.on("close", (code2) => {
          if (code2 === 0) {
            console.log(`  Switched to existing branch: ${branchName}`);
            resolve(true);
          } else {
            console.error(`  Failed to create/switch to branch: ${branchName}`);
            resolve(false);
          }
        });
      }
    });
  });
}

async function commitAndPush(
  issueIdentifier: string,
  title: string
): Promise<boolean> {
  const projectRoot = path.join(import.meta.dirname, "..");

  // Stage all changes
  const addResult = await new Promise<boolean>((resolve) => {
    const git = spawn("git", ["add", "-A"], { cwd: projectRoot });
    git.on("close", (code) => resolve(code === 0));
  });
  if (!addResult) {
    console.error("  Failed to stage changes");
    return false;
  }

  // Check if there are changes to commit
  const statusResult = await new Promise<string>((resolve) => {
    const git = spawn("git", ["status", "--porcelain"], { cwd: projectRoot });
    let output = "";
    git.stdout.on("data", (data) => { output += data.toString(); });
    git.on("close", () => resolve(output.trim()));
  });

  if (!statusResult) {
    console.error("  No changes to commit");
    return false;
  }

  // Commit
  const commitMessage = `${title}\n\nImplements ${issueIdentifier}\n\nCo-Authored-By: Claude <noreply@anthropic.com>`;
  const commitResult = await new Promise<boolean>((resolve) => {
    const git = spawn("git", ["commit", "-m", commitMessage], { cwd: projectRoot });
    git.on("close", (code) => resolve(code === 0));
  });
  if (!commitResult) {
    console.error("  Failed to commit changes");
    return false;
  }
  console.log("  Committed changes");

  // Push
  const pushResult = await new Promise<boolean>((resolve) => {
    const git = spawn("git", ["push", "-u", "origin", "HEAD"], { cwd: projectRoot });
    git.on("close", (code) => resolve(code === 0));
  });
  if (!pushResult) {
    console.error("  Failed to push changes");
    return false;
  }
  console.log("  Pushed to remote");

  return true;
}

async function createPullRequest(
  title: string,
  issueIdentifier: string,
  issueUrl: string
): Promise<string | null> {
  return new Promise((resolve) => {
    const body = `## Summary
Implements ${issueIdentifier}

## Linear Issue
${issueUrl}

---
ü§ñ Generated by Linear Agent`;

    const gh = spawn("gh", [
      "pr",
      "create",
      "--title",
      title,
      "--body",
      body
    ], {
      cwd: path.join(import.meta.dirname, "..")
    });

    let prUrl = "";
    let stderr = "";
    gh.stdout.on("data", (data) => {
      const output = data.toString().trim();
      if (output.includes("github.com")) {
        prUrl = output;
      }
    });
    gh.stderr.on("data", (data) => {
      stderr += data.toString();
    });

    gh.on("close", (code) => {
      if (code === 0 && prUrl) {
        console.log(`  PR created: ${prUrl}`);
        resolve(prUrl);
      } else {
        console.error("  Failed to create PR:", stderr);
        resolve(null);
      }
    });
  });
}

async function runAgent(
  issue: LinearIssue,
  agentType: "feature" | "fix",
  logPath: string
): Promise<{ success: boolean; error?: string }> {
  return new Promise((resolve) => {
    const logStream = createWriteStream(logPath, { flags: "a" });
    const startTime = Date.now();

    const header = `
================================================================================
Linear Issue: ${issue.identifier}
Title: ${issue.title}
Agent: ${agentType}
Started: ${new Date().toISOString()}
================================================================================

${issue.description || "No description provided."}

--------------------------------------------------------------------------------
AGENT OUTPUT:
--------------------------------------------------------------------------------

`;
    logStream.write(header);
    console.log(`  Log file: ${logPath}`);

    const prompt = `${issue.title}${issue.description ? `\n\n${issue.description}` : ""}`;
    const projectRoot = path.join(import.meta.dirname, "..");
    const agentScript = path.join(import.meta.dirname, `${agentType}-agent.ts`);

    // Run tsx directly with the agent script, avoiding shell interpretation
    const agent = spawn("npx", ["tsx", agentScript, prompt], {
      cwd: projectRoot,
      shell: false,
      env: { ...process.env, FORCE_COLOR: "0" }
    });

    agent.stdout.on("data", (data) => {
      const line = data.toString();
      process.stdout.write(line);
      logStream.write(line);
    });

    agent.stderr.on("data", (data) => {
      const line = data.toString();
      process.stderr.write(line);
      logStream.write(`[STDERR] ${line}`);
    });

    agent.on("close", (code) => {
      const duration = ((Date.now() - startTime) / 1000).toFixed(1);
      const footer = `

--------------------------------------------------------------------------------
COMPLETED
--------------------------------------------------------------------------------
Exit code: ${code}
Duration: ${duration}s
Finished: ${new Date().toISOString()}
================================================================================
`;
      logStream.write(footer);
      logStream.end();

      if (code === 0) {
        resolve({ success: true });
      } else {
        resolve({
          success: false,
          error: `Agent exited with code ${code}`
        });
      }
    });

    agent.on("error", (err) => {
      const errorMsg = `Agent spawn error: ${err.message}`;
      logStream.write(`\n[ERROR] ${errorMsg}\n`);
      logStream.end();
      resolve({ success: false, error: errorMsg });
    });
  });
}

async function processIssue(issue: LinearIssue): Promise<void> {
  const agentType = getAgentType(issue.labels);

  console.log(`\n${"=".repeat(60)}`);
  console.log(`Processing: ${issue.identifier} - ${issue.title}`);
  console.log(`Agent: ${agentType}`);
  console.log(`Labels: ${issue.labels.join(", ")}`);
  console.log(`${"=".repeat(60)}`);

  const logPath = getLogFilePath(issue.identifier);

  try {
    await markAsProcessing(issue.id);

    const branchCreated = await createBranch(issue.branchName);
    if (!branchCreated) {
      throw new Error("Failed to create/switch to branch");
    }

    const result = await runAgent(issue, agentType, logPath);

    if (result.success) {
      // Commit and push changes
      const pushed = await commitAndPush(issue.identifier, issue.title);
      if (!pushed) {
        throw new Error("Failed to commit and push changes");
      }

      // Create PR
      const prUrl = await createPullRequest(
        issue.title,
        issue.identifier,
        issue.url
      );

      if (prUrl) {
        await markAsComplete(issue.id, prUrl);
        saveProcessedIssue(issue.id, issue.identifier, "success", prUrl);
        console.log(`\n‚úÖ Successfully completed ${issue.identifier}`);
      } else {
        throw new Error("Failed to create pull request");
      }
    } else {
      throw new Error(result.error || "Agent failed");
    }
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    console.error(`\n‚ùå Failed to process ${issue.identifier}: ${errorMsg}`);
    await markAsFailed(issue.id, errorMsg);
    saveProcessedIssue(issue.id, issue.identifier, "failed", undefined, errorMsg);
  }

  await spawn("git", ["checkout", "main"], {
    cwd: path.join(import.meta.dirname, "..")
  });
}

async function poll(): Promise<void> {
  console.log(`\n[${new Date().toISOString()}] Polling Linear for issues...`);

  try {
    const issues = await getInProgressIssuesWithAgentLabel();

    const newIssues = issues.filter(issue => !isAlreadyProcessed(issue.id));

    if (newIssues.length === 0) {
      console.log("  No new issues to process.");
      return;
    }

    console.log(`  Found ${newIssues.length} new issue(s) to process.`);

    for (const issue of newIssues) {
      await processIssue(issue);
    }
  } catch (error) {
    console.error("  Error polling Linear:", error instanceof Error ? error.message : error);
  }
}

async function main(): Promise<void> {
  console.log("\nüîó Linear Agent Runner");
  console.log("‚îÅ".repeat(50));
  console.log("Monitoring for issues with 'Agent' label in 'In Progress'");
  console.log(`Poll interval: ${POLL_INTERVAL_MS / 1000} seconds`);
  console.log("‚îÅ".repeat(50));

  if (!process.env.LINEAR_API_KEY) {
    console.error("\n‚ùå ERROR: LINEAR_API_KEY environment variable is required");
    console.error("  Set it in agents/.env or export it in your shell");
    process.exit(1);
  }

  await mkdir(LOGS_DIR, { recursive: true });

  const runOnce = process.argv.includes("--once");

  if (runOnce) {
    console.log("\nRunning once (--once flag detected)");
    await poll();
    console.log("\nDone.");
  } else {
    console.log("\nPress Ctrl+C to stop.\n");
    await poll();
    setInterval(poll, POLL_INTERVAL_MS);
  }
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
